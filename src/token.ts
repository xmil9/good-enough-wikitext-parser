//
// Tokens generated by the tokenizer.
//

///////////////////

export enum TokenType {
  TEXT = 'text',
  ITALIC = 'italic-toggle', // ''
  BOLD = 'bold-toggle', // '''
  NEW_PARAGRAPH = 'new-paragraph', // blank line
  OPEN_START_TAG = 'open-start-tag', // <
  OPEN_END_TAG = 'open-end-tag', // </
  CLOSE_TAG = 'close-tag', // >
  CLOSE_AND_END_TAG = 'close-and-end-tag', // />
  TAG_NAME = 'tag-name', // name of html or wikitext extension tag
  SIGNATURE = 'signature', // ~~~
  SIGNATURE_DATETIME = 'signature-date-time', // ~~~~
  DATE_TIME = 'date-time', // ~~~~~
  TEMPLATE_BEGIN = 'template-begin', // {{
  TEMPLATE_END = 'template-end', // }}
  COMMENT_BEGIN = 'comment-begin', // <!--
  COMMENT_END = 'comment-end', // -->
  HEADING_BEGIN = 'heading-begin', // = (up to 6)
  HEADING_END = 'heading-end', // =
  // *'s at start of line or after previous # (count determines indent)
  UNORDERED_LIST_ENTRY = 'unordered-list-entry',
  // #'s at start of line or atfer previous * (count determines indent)
  NUMBERED_LIST_ENTRY = 'numbered-list-entry',
  DEFINED_PHRASE = 'defined-phrase', // ; at start of line or after previous * or #
  DEFINITION = 'definition', // : after defined phrase (multiple definitions possible)
  INDENT = 'indent', // : at start of line (count determines indent)
  HORZ_DIVIDER = 'horz-divider', // ----
  LINK_BEGIN = 'link-begin', // [[
  LINK_END = 'link-end', // ]]
  EXT_LINK_BEGIN = 'ext-link-begin', // [
  EXT_LINK_END = 'ext-link-end', // ]
  PIPE = 'pipe', // |
  SPACE = 'space', // ' '
  COLON = 'colon', // links with colons are category links
  URL = 'url', // http(s)://
  EMAIL = 'email', // mailto:
  REDIRECT = 'redirect', // #REDIRECT
  FORCETOC = 'forcetoc', // __FORCETOC__
  TOC = 'toc', // __TOC__
  NOTOC = 'notoc', // __NOTOC__
  NBSP = 'nbsp', // &nbsp; - non-breaking space
  // &<char-ref>; with <char-ref> a multi-letter reference for a special char,
  // e.g. &quot; for "
  SPECIAL_CHAR = 'special-char',
  UNICODE_CHAR = 'unicode-char', // &#<code>
  TABLE_BEGIN = 'table-begin', // {|
  TABLE_END = 'table-end', // |}
  // Special token for ambiguous situation:
  // ---->
  // Depending on the context this could be:
  // 1) TEXT COMMENT_END
  //    if a multi line comment context is open.
  // 2) HORZ_DIVIDER TEXT
  //    if a multi line comment context is not open.
  // Solution:
  // Generate special token and let parser decide based on context.
  COMMENT_END_OR_HORZ_DIV = 'comment-end-or-horz-div'
}

export class Token {
  private readonly _type: TokenType;
  private readonly _value: string;
  private readonly _lineNum: number;

  constructor(type: TokenType, value: string, lineNum: number) {
    this._type = type;
    this._value = value;
    this._lineNum = lineNum;
  }

  public get type(): TokenType {
    return this._type;
  }

  public get value(): string {
    return this._value;
  }

  public get lineNumber(): number {
    return this._lineNum;
  }

  // Returns string indicating the location of the token in the source file.
  public location(): string {
    return `Line: ${this._lineNum}`;
  }
}
